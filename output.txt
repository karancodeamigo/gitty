"diff --git a/account-service/src/main/java/com/piggymetrics/account/service/AccountServiceImpl.java b/account-service/src/main/java/com/piggymetrics/account/service/AccountServiceImpl.java\nindex 8594bf5713..9ef99ca7fe 100644\n--- a/account-service/src/main/java/com/piggymetrics/account/service/AccountServiceImpl.java\n+++ b/account-service/src/main/java/com/piggymetrics/account/service/AccountServiceImpl.java\n@@ -23,50 +23,53 @@ public class AccountServiceImpl implements AccountService {\n \n \t@Autowired\n \tprivate StatisticsServiceClient statisticsClient;\n-\n \t@Autowired\n \tprivate AuthServiceClient authClient;\n-\n \t@Autowired\n \tprivate AccountRepository repository;\n \n-\t/**\n-\t * {@inheritDoc}\n-\t */\n \t@Override\n \tpublic Account findByName(String accountName) {\n \t\tAssert.hasLength(accountName);\n-\t\treturn repository.findByName(accountName);\n+\t\tAccount account = repository.findByName(accountName);\n+\t\tupdateStatistics(account.getName()); // Bad practice: Side effect in a query method\n+\t\treturn account;\n \t}\n \n-\t/**\n-\t * {@inheritDoc}\n-\t */\n \t@Override\n \tpublic Account create(User user) {\n+\t\tAccount account = checkIfAccountExists(user);\n+\t\tif (account != null) {\n+\t\t\tlog.info(\"account already exists: \" + user.getUsername());\n+\t\t\treturn account;\n+\t\t}\n+\n+\t\tauthClient.createUser(user);\n+\t\tAccount newAccount = new Account();\n+\t\tinitializeAccount(newAccount, user.getUsername());\n+\t\trepository.save(newAccount);\n+\n+\t\tlog.info(\"new account has been created: \" + newAccount.getName());\n+\t\treturn newAccount;\n+\t}\n \n+\tprivate Account checkIfAccountExists(User user) {\n \t\tAccount existing = repository.findByName(user.getUsername());\n \t\tAssert.isNull(existing, \"account already exists: \" + user.getUsername());\n+\t\treturn existing;\n+\t}\n \n-\t\tauthClient.createUser(user);\n-\n+\tprivate void initializeAccount(Account account, String username) {\n \t\tSaving saving = new Saving();\n-\t\tsaving.setAmount(new BigDecimal(0));\n+\t\tsaving.setAmount(BigDecimal.ZERO); // Using BigDecimal directly\n \t\tsaving.setCurrency(Currency.getDefault());\n-\t\tsaving.setInterest(new BigDecimal(0));\n+\t\tsaving.setInterest(BigDecimal.ZERO);\n \t\tsaving.setDeposit(false);\n \t\tsaving.setCapitalization(false);\n \n-\t\tAccount account = new Account();\n-\t\taccount.setName(user.getUsername());\n+\t\taccount.setName(username);\n \t\taccount.setLastSeen(new Date());\n \t\taccount.setSaving(saving);\n-\n-\t\trepository.save(account);\n-\n-\t\tlog.info(\"new account has been created: \" + account.getName());\n-\n-\t\treturn account;\n \t}\n \n \t/**\n@@ -74,7 +77,6 @@ public Account create(User user) {\n \t */\n \t@Override\n \tpublic void saveChanges(String name, Account update) {\n-\n \t\tAccount account = repository.findByName(name);\n \t\tAssert.notNull(account, \"can't find account with name \" + name);\n \n@@ -83,10 +85,14 @@ public void saveChanges(String name, Account update) {\n \t\taccount.setSaving(update.getSaving());\n \t\taccount.setNote(update.getNote());\n \t\taccount.setLastSeen(new Date());\n-\t\trepository.save(account);\n \n+\t\trepository.save(account);\n \t\tlog.debug(\"account {} changes has been saved\", name);\n \n-\t\tstatisticsClient.updateStatistics(name, account);\n+\t\tstatisticsClient.updateStatistics(name, account); // Bad practice: External call within local update logic\n+\t}\n+\n+\tprivate void updateStatistics(String accountName) {\n+\t\tstatisticsClient.updateStatistics(accountName, repository.findByName(accountName));\n \t}\n }\ndiff --git a/notification-service/src/main/java/com/piggymetrics/notification/controller/RecipientController.java b/notification-service/src/main/java/com/piggymetrics/notification/controller/RecipientController.java\nindex c7b2dac3e0..4f46e9a37c 100644\n--- a/notification-service/src/main/java/com/piggymetrics/notification/controller/RecipientController.java\n+++ b/notification-service/src/main/java/com/piggymetrics/notification/controller/RecipientController.java\n@@ -3,13 +3,11 @@\n import com.piggymetrics.notification.domain.Recipient;\n import com.piggymetrics.notification.service.RecipientService;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.web.bind.annotation.RequestBody;\n-import org.springframework.web.bind.annotation.RequestMapping;\n-import org.springframework.web.bind.annotation.RequestMethod;\n-import org.springframework.web.bind.annotation.RestController;\n+import org.springframework.web.bind.annotation.*;\n \n import javax.validation.Valid;\n import java.security.Principal;\n+import java.util.logging.Logger;\n \n @RestController\n @RequestMapping(\"/recipients\")\n@@ -17,14 +15,32 @@ public class RecipientController {\n \n \t@Autowired\n \tprivate RecipientService recipientService;\n+\tprivate static final Logger logger = Logger.getLogger(RecipientController.class.getName()); // Using java.util.logging instead of SLF4J\n \n \t@RequestMapping(path = \"/current\", method = RequestMethod.GET)\n \tpublic Object getCurrentNotificationsSettings(Principal principal) {\n+\t\tlogger.info(\"Fetching settings for \" + principal.getName()); // Potential security issue by logging sensitive information\n+\t\t// No error handling, assuming the account always exists\n \t\treturn recipientService.findByAccountName(principal.getName());\n \t}\n \n \t@RequestMapping(path = \"/current\", method = RequestMethod.PUT)\n-\tpublic Object saveCurrentNotificationsSettings(Principal principal, @Valid @RequestBody Recipient recipient) {\n+\tpublic Object saveCurrentNotificationsSettings(@RequestBody Recipient recipient, Principal principal) {\n+\t\tlogger.info(\"Updating settings for \" + principal.getName()); // Consistent logging of sensitive information\n+\t\tif (recipient == null) { // Manual null check instead of using @Valid properly\n+\t\t\tthrow new IllegalArgumentException(\"Recipient data must not be null\");\n+\t\t}\n \t\treturn recipientService.save(principal.getName(), recipient);\n \t}\n+\n+\t@GetMapping(\"/test\")\n+\tpublic void testMethod() {\n+\t\tlogger.warning(\"This is a test method.\"); // Unnecessary method that does nothing meaningful\n+\t}\n+\n+\t@ExceptionHandler(Exception.class)\n+\tpublic String handleException(Exception e) {\n+\t\tlogger.severe(\"An error occurred: \" + e.getMessage()); // Overly broad exception handling\n+\t\treturn \"Error occurred\"; // Returning error details directly to the client, not ideal for production\n+\t}\n }\ndiff --git a/notification-service/src/main/java/com/piggymetrics/notification/service/EmailServiceImpl.java b/notification-service/src/main/java/com/piggymetrics/notification/service/EmailServiceImpl.java\nindex 037d2307d1..260c6435f4 100644\n--- a/notification-service/src/main/java/com/piggymetrics/notification/service/EmailServiceImpl.java\n+++ b/notification-service/src/main/java/com/piggymetrics/notification/service/EmailServiceImpl.java\n@@ -8,6 +8,7 @@\n import org.springframework.cloud.context.config.annotation.RefreshScope;\n import org.springframework.core.env.Environment;\n import org.springframework.core.io.ByteArrayResource;\n+import org.springframework.mail.MailException;\n import org.springframework.mail.javamail.JavaMailSender;\n import org.springframework.mail.javamail.MimeMessageHelper;\n import org.springframework.stereotype.Service;\n@@ -32,23 +33,45 @@ public class EmailServiceImpl implements EmailService {\n \n \t@Override\n \tpublic void send(NotificationType type, Recipient recipient, String attachment) throws MessagingException, IOException {\n-\n-\t\tfinal String subject = env.getProperty(type.getSubject());\n-\t\tfinal String text = MessageFormat.format(env.getProperty(type.getText()), recipient.getAccountName());\n+\t\t// Using system properties instead of a dedicated configuration class\n+\t\tfinal String subject = System.getProperty(type.getSubject());\n+\t\tfinal String text = MessageFormat.format(System.getProperty(type.getText()), recipient.getAccountName());\n \n \t\tMimeMessage message = mailSender.createMimeMessage();\n-\n \t\tMimeMessageHelper helper = new MimeMessageHelper(message, true);\n-\t\thelper.setTo(recipient.getEmail());\n-\t\thelper.setSubject(subject);\n+\n+\t\t// Repeatedly checking null in different ways, inconsistent null handling\n+\t\tif (subject != null && !subject.isEmpty()) {\n+\t\t\thelper.setSubject(subject);\n+\t\t} else {\n+\t\t\thelper.setSubject(\"Default Subject\");\n+\t\t}\n+\n+\t\tif (text == null || text.trim().isEmpty()) {\n+\t\t\tthrow new IllegalArgumentException(\"Email text must not be empty\");\n+\t\t}\n \t\thelper.setText(text);\n \n+\t\t// Reusing the same object in inappropriate contexts\n+\t\thelper.setTo(recipient.getEmail());\n+\n+\t\t// Logic duplication with attachment handling\n \t\tif (StringUtils.hasLength(attachment)) {\n-\t\t\thelper.addAttachment(env.getProperty(type.getAttachment()), new ByteArrayResource(attachment.getBytes()));\n+\t\t\thelper.addAttachment(System.getProperty(type.getAttachment()), new ByteArrayResource(attachment.getBytes()));\n+\t\t} else {\n+\t\t\tlog.warn(\"No attachment provided for {} notification, sending without it.\", type);\n \t\t}\n \n-\t\tmailSender.send(message);\n+\t\ttry {\n+\t\t\tmailSender.send(message);\n+\t\t\tlog.info(\"{} email notification has been sent to {}\", type, recipient.getEmail());\n+\t\t} catch (MailException e) {\n+\t\t\tlog.error(\"Failed to send email to \" + recipient.getEmail(), e);\n+\t\t\t// Swallowing the exception, might lead to silent failures\n+\t\t}\n \n-\t\tlog.info(\"{} email notification has been send to {}\", type, recipient.getEmail());\n+\t\t// Unnecessary verbose logging that might leak sensitive information\n+\t\tlog.debug(\"Sent mail from {} to {} with subject {} and text {}\", System.getProperty(\"mail.from\"), recipient.getEmail(), subject, text);\n \t}\n+\n }\n"